<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://kangduu.github.io/website/website/rss.xml" rel="self" type="application/rss+xml"/>
    <title>大眼猫看前端</title>
    <link>https://kangduu.github.io/website/website/</link>
    <description>HTML、CSS、JavaScript、TypeScript、React、Vue...</description>
    <language>zh-CN</language>
    <pubDate>Mon, 16 May 2022 15:34:39 GMT</pubDate>
    <lastBuildDate>Mon, 16 May 2022 15:34:39 GMT</lastBuildDate>
    <generator>@mr-hope/vuepress-plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>interview</category>
    <category>React</category>
    <item>
      <title>React 系列文章</title>
      <link>https://kangduu.github.io/website/website/case/</link>
      <guid>https://kangduu.github.io/website/website/case/</guid>
      <source url="https://kangduu.github.io/website/website/rss.xml">React 系列文章</source>
      <pubDate>Thu, 05 May 2022 10:01:30 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="react-系列文章"> React 系列文章</h1>
]]></content:encoded>
    </item>
    <item>
      <title>Frond End Interview</title>
      <link>https://kangduu.github.io/website/website/interview/</link>
      <guid>https://kangduu.github.io/website/website/interview/</guid>
      <source url="https://kangduu.github.io/website/website/rss.xml">Frond End Interview</source>
      <category>interview</category>
      <pubDate>Thu, 05 May 2022 10:01:30 GMT</pubDate>
      <content:encoded><![CDATA[<GithubIssueList />
]]></content:encoded>
    </item>
    <item>
      <title>React高阶组件（HOC）</title>
      <link>https://kangduu.github.io/website/website/react/HOC.html</link>
      <guid>https://kangduu.github.io/website/website/react/HOC.html</guid>
      <source url="https://kangduu.github.io/website/website/rss.xml">React高阶组件（HOC）</source>
      <category>React</category>
      <pubDate>Mon, 16 May 2022 14:56:12 GMT</pubDate>
      <content:encoded><![CDATA[<ol>
<li></li>
<li>有几种高阶组件（实现）？各种的优缺点是什么？</li>
<li>你平时是如何写高阶组件的？</li>
<li>HOC 怎么处理静态属性、跨层级 ref 等问题？</li>
<li>高阶组件怎么控制渲染？隔离渲染？</li>
<li>高阶组件如何监视原始组件状态？</li>
</ol>
<h2 id="什么是高阶组件"> 什么是高阶组件？</h2>
<p><a href="https://react.docschina.org/docs/higher-order-components.html" target="_blank" rel="noopener noreferrer">🙋 高阶组件</a> 是 <strong>参数为组件</strong>，<strong>返回值为新组件</strong> 的 <strong>函数</strong></p>
<div><pre><code><span>const</span> EnhancedComponent <span>=</span> <span>higherOrderComponent</span><span>(</span>WrappedComponent<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>🤔 <strong>Questions：</strong> 高阶组件与组件之间的差别是什么？</p>
<p>🙋 <strong>Answer：</strong> 组件是将 props 和 state 转化为 UI，而高阶组件是将组件转换为另一个组件。</p>
<p>为了后期维护方便。<u>最好是一个纯函数，尽量不要有副作用。</u></p>
<h2 id="高阶组件解决了哪些问题-高阶组件产生的初衷"> 高阶组件解决了哪些问题？（高阶组件产生的初衷？）</h2>
<ol>
<li>逻辑复用</li>
<li>props 强化</li>
<li>组件赋能</li>
<li>控制渲染</li>
</ol>
<p>🤔 <strong>思考：</strong> 在没有高阶组件之前，又是如何处理这些问题的啦？</p>
<h2 id="如何优雅的写一个高阶组件"> 如何优雅的写一个高阶组件？</h2>
<ol>
<li>普通模式</li>
<li>装饰器</li>
<li>多高阶组件组合</li>
</ol>
<h2 id="高阶组件能用来做什么"> 高阶组件能用来做什么？</h2>
<h2 id="说说我们平时使用的轮子中使用了-hoc-技术的有哪些啦"> 说说我们平时使用的轮子中使用了 HOC 技术的有哪些啦？</h2>
<blockquote>
<p>Redux 中的 <code>connect()</code></p>
<p>React Router 中的 <code>withRoute</code></p>
<p>Relay 中的 <code>createFragmentContainer</code></p>
</blockquote>
<h2 id="总结"> 总结</h2>
<h2 id="参考文献"> 参考文献</h2>
<ul>
<li><a href="https://juejin.cn/post/6940422320427106335" target="_blank" rel="noopener noreferrer">「react 进阶」一文吃透 React 高阶组件(HOC)</a></li>
<li><a href="https://juejin.cn/post/6844904050236850184" target="_blank" rel="noopener noreferrer">React 高阶组件(HOC)的入门 📖 及实践 💻</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>深入浅出 React 系列</title>
      <link>https://kangduu.github.io/website/website/react/</link>
      <guid>https://kangduu.github.io/website/website/react/</guid>
      <source url="https://kangduu.github.io/website/website/rss.xml">深入浅出 React 系列</source>
      <description>用于构建用户界面的 JavaScript 库</description>
      <category>React</category>
      <pubDate>Thu, 05 May 2022 10:01:30 GMT</pubDate>
      <content:encoded><![CDATA[
<div><p>提示</p>
<p>这是一个提示</p>
</div>
<div><p>注意</p>
<p>这是一个警告</p>
</div>
<div><p>警告</p>
<p>这是一个危险警告</p>
</div>
<details><summary>DETAILS</summary>
<p>这是一个详情块，在 Internet Explorer / Edge 中不生效</p>
</details>
<h3 id="react-组件模式"> React 组件模式</h3>
<h3 id="阅读角"> 阅读角</h3>
<ul>
<li><a href="https://overreacted.io/" target="_blank" rel="noopener noreferrer">overreacted</a></li>
<li><a href="https://www.30secondsofcode.org/react/p/1" target="_blank" rel="noopener noreferrer">30 seconds of code with react</a></li>
<li><a href="https://ahooks.js.org/zh-CN" target="_blank" rel="noopener noreferrer">ahooks</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>官方文档</title>
      <link>https://kangduu.github.io/website/website/react/useEffect%E5%92%8CuseLayoutEffect%E7%9A%84%E5%8C%BA%E5%88%AB.html</link>
      <guid>https://kangduu.github.io/website/website/react/useEffect%E5%92%8CuseLayoutEffect%E7%9A%84%E5%8C%BA%E5%88%AB.html</guid>
      <source url="https://kangduu.github.io/website/website/rss.xml">官方文档</source>
      <pubDate>Mon, 16 May 2022 14:56:12 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="官方文档"> 官方文档</h2>
<h3 id="useeffect"> useEffect</h3>
<div><pre><code><span>useEffect</span><span>(</span>didUpdate<span>[</span><span>,</span><span>[</span>dep<span>]</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><ol>
<li>
<p>赋值给 <code>useEffect</code> 的函数 didUpdate 会在<u>组件渲染到屏幕之后</u>执行。 即待浏览器完成画面渲染之后才会延迟调用 <code>useEffect</code> 。</p>
</li>
<li>
<p>清除函数（didUpdate的返回值）。 为防止内存泄漏，清除函数会<u>在组件卸载前执行</u>。  如果组件多次渲染（通常如此），则<strong>在执行下一个 effect 之前，上一个 effect 就已被清除</strong>。</p>
<div><pre><code>useEffect(() =&gt; {
  const subscription = props.source.subscribe();
  return () =&gt; {
    // 清除订阅
    subscription.unsubscribe();
  };
});
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 不同的是，在浏览器完成布局与绘制<strong>之后</strong>，传给 <code>useEffect</code> 的函数<u>会延迟调用</u>。</p>
</li>
<li>
<p>虽然 <code>useEffect</code> 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。</p>
</li>
</ol>
<p>详见<a href="https://react.docschina.org/docs/hooks-reference.html#useeffect" target="_blank" rel="noopener noreferrer">useLayoutEffect</a></p>
<h3 id="uselayouteffect"> useLayoutEffect</h3>
<div><pre><code>useLayoutEffect(didUpdate[,[dep]]);
</code></pre>
<div><span>1</span><br></div></div><p>​		其函数签名与 <code>useEffect</code> 相同，但它<u>会在所有的 DOM 变更之后同步调用 effect</u>。可以使用它来<u><strong>读取 DOM 布局并同步触发重渲染</strong></u>。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p>
<p>​		尽可能使用标准的 useEffect 以避免阻塞视觉更新。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果你正在将代码从 class 组件迁移到使用 Hook 的函数组件，则<u>需要注意 <code>useLayoutEffect</code> 与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 的调用阶段是一样的</u>。但是，我们推荐你<strong>一开始先用 <code>useEffect</code></strong>，只有当它出问题的时候再尝试使用 <code>useLayoutEffect</code>。</p>
<p>......服务端渲染相关内容，详见<a href="https://react.docschina.org/docs/hooks-reference.html#uselayouteffect" target="_blank" rel="noopener noreferrer">useLayoutEffect</a></p>
</blockquote>
<h2 id="最大的不同"> 最大的不同</h2>
<p><strong>调用时机的不同</strong></p>
<ol>
<li><code>useLayoutEffect</code> 与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 的调用阶段是一样的。</li>
<li>在浏览器完成布局与绘制<strong>之后</strong>，传给 <code>useEffect</code> 的函数会延迟调用。</li>
</ol>
<p>🌰举例说明useEffect和useLayoutEffect的调用时机不同：</p>
<div><pre><code><span>// Parent.jsx</span>
<span>import</span> React<span>,</span> <span>{</span> Component <span>}</span> <span>from</span> <span>"react"</span><span>;</span>
<span>import</span> Child <span>from</span> <span>"./Child"</span><span>;</span>
<span>export</span> <span>default</span> <span>class</span> <span>Parent</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"[Parent] componentDidMount"</span><span>)</span><span>;</span>
  <span>}</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span><span><span>&lt;</span><span>Child</span></span> <span>/></span></span><span>;</span>
  <span>}</span>
<span>}</span>

<span>// Child.jsx</span>
<span>import</span> React<span>,</span> <span>{</span> useEffect<span>,</span> useLayoutEffect <span>}</span> <span>from</span> <span>"react"</span><span>;</span>
<span>export</span> <span>default</span> <span>function</span> <span>Test</span><span>(</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"[Child] useEffect mount"</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
  <span>useLayoutEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"[Child] useLayoutEffect mount"</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
  <span>return</span> <span><span><span>&lt;</span>div</span><span>></span></span><span>Child</span><span><span><span>&lt;/</span>div</span><span>></span></span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>🙋 <em><strong>Answer：</strong></em> 上述案例的日志结果如下。</p>
<div><pre><code>[Child] useLayoutEffect mount   // 子组件挂载完成
[Parent] componentDidMount		// 父组件挂载完成
[Child] useEffect mount			// useEffect延迟调用了
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="什么情况下使用uselayouteffect"> 什么情况下使用useLayoutEffect？</h2>
<p>在浏览器执行下一次绘制前，用户可见的 DOM 变更必须同步执行，这样用户才不会感觉到视觉上的不一致 。</p>
]]></content:encoded>
    </item>
    <item>
      <title>React@18 新特性</title>
      <link>https://kangduu.github.io/website/website/react/%E3%80%90React_V18%E3%80%91react@18+%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</link>
      <guid>https://kangduu.github.io/website/website/react/%E3%80%90React_V18%E3%80%91react@18+%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</guid>
      <source url="https://kangduu.github.io/website/website/rss.xml">React@18 新特性</source>
      <category>React</category>
      <pubDate>Mon, 16 May 2022 14:56:12 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="react-18"> React 18</h3>
<ul>
<li>
<p><a href="./[性能优化]React.flushSync处理异步批量setState导致多次更新.html">Automatic batching 自动批处理</a></p>
</li>
<li>
<p>New APIS</p>
<ul>
<li>concurrent features
<ul>
<li><a href="https://reactjs.org/docs/react-api.html#starttransition" target="_blank" rel="noopener noreferrer">React.startTransition()</a></li>
<li><a href="https://reactjs.org/docs/hooks-reference.html#usedeferredvalue" target="_blank" rel="noopener noreferrer">useDeferredValue()</a></li>
<li><a href="https://reactjs.org/docs/hooks-reference.html#usetransition" target="_blank" rel="noopener noreferrer">useTransition()</a></li>
</ul>
</li>
<li>mostly for libraries
<ul>
<li><a href="https://reactjs.org/docs/hooks-reference.html#useid" target="_blank" rel="noopener noreferrer">useId()</a></li>
<li><a href="https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore" target="_blank" rel="noopener noreferrer">useSyncExternalStore()</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Suspense on the server</p>
</li>
</ul>
<h3 id="react-dom-18"> react-dom 18</h3>
<ul>
<li>New Render API
<ul>
<li><a href="https://reactjs.org/docs/react-dom-client.html#createroot" target="_blank" rel="noopener noreferrer">ReactDOM.createRoot</a>:需要将<code>ReactDOM.render</code>切换到<code>ReactDOM。createRoot</code></li>
</ul>
</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=ytudH8je5ko" target="_blank" rel="noopener noreferrer">官方演示视频</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Automatic Batching Update</title>
      <link>https://kangduu.github.io/website/website/react/%E3%80%90%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%91React.flushSync%E4%B8%8EAutomaticBatching.html</link>
      <guid>https://kangduu.github.io/website/website/react/%E3%80%90%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%91React.flushSync%E4%B8%8EAutomaticBatching.html</guid>
      <source url="https://kangduu.github.io/website/website/rss.xml">Automatic Batching Update</source>
      <category>React</category>
      <pubDate>Mon, 16 May 2022 14:56:12 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="automatic-batching-update"> Automatic Batching Update</h1>
<h3 id="react-是如何进行自动批处理更新的"> React 是如何进行自动批处理更新的？</h3>
<p><strong>在 React@18.0.0之前</strong>，我们使用 setState 或者 Hook 修改状态后，并不会立即触发重新渲染。React 会执行全部事件处理函数，然后触发一个单独的 re-render，<strong>合并所有更新</strong>。 <em>—— tips：只能处理同步任务</em></p>
<p>🌰 写一个案例，实现<strong>多次</strong>同步调用 setState 或 hooks</p>
<div><pre><code><span>import</span> <span>{</span> useEffect<span>,</span> useState <span>}</span> <span>from</span> <span>"react"</span><span>;</span>

<span>const</span> <span>Increment</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"count value:"</span><span>,</span> count<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>const</span> <span>incermentHandler</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>

  <span>return</span> <span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span>incermentHandler<span>}</span></span><span>></span></span><span>点击</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>;</span>
<span>}</span><span>;</span>

<span>export</span> <span>default</span> Increment<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>当我们点击按钮后，控制台应该打印什么日志信息啦？</p>
<div><pre><code>count value<span>:</span> <span>1</span>
count value<span>:</span> <span>2</span>
count value<span>:</span> <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>是这样吗？并不是。</p>
<p>正确结果：</p>
<div><pre><code><span>count value:</span> <span>3</span>
</code></pre>
<div><span>1</span><br></div></div><p>🌰 同样的代码，修改一下处理函数调用 setState 或 hooks 的方式。</p>
<div><pre><code><span>...</span>

<span>const</span> <span>incermentHandler</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span> <span>// Promise Ajax ...</span>
        <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>300</span><span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>...</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果你像上面这样更新状态，console 日志信息打印结果？</p>
<div><pre><code>count value<span>:</span> <span>1</span>
count value<span>:</span> <span>2</span>
count value<span>:</span> <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>是的，就是更新了三次。意不意外，惊不惊喜！</p>
<p>还记得一开始我们说的吗？合并所有更新，只能是同步的任务。</p>
<p>那我们就不能在异步任务中多次修改 state 了吗？完全可以，而且也可以只更新一次。</p>
<h3 id="使用reactdom-flushsync解决异步多次修改状态导致多次更新的问题"> 使用<code>ReactDOM.flushSync</code>解决异步多次修改状态导致多次更新的问题</h3>
<div><pre><code><span>// flushSync</span>
<span>export</span> <span>function</span> <span><span>flushSync</span><span><span>&lt;</span><span>R</span><span>></span></span></span><span>(</span><span>fn</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>R</span><span>)</span><span>:</span> <span>R</span><span>;</span>
<span>export</span> <span>function</span> <span><span>flushSync</span><span><span>&lt;</span><span>A</span><span>,</span> <span>R</span><span>></span></span></span><span>(</span><span>fn</span><span>:</span> <span>(</span>a<span>:</span> <span>A</span><span>)</span> <span>=></span> <span>R</span><span>,</span> a<span>:</span> <span>A</span><span>)</span><span>:</span> <span>R</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>import</span> ReactDOM <span>from</span> <span>"react-dom"</span><span>;</span>

<span>...</span>

<span>const</span> <span>incermentHandler</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
<span>+</span>        ReactDOM<span>.</span><span>flushSync</span><span>(</span><span>(</span><span>)</span><span>=></span><span>{</span>
            <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>
            <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>
            <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>
<span>+</span>        <span>}</span><span>)</span>
    <span>}</span><span>,</span> <span>300</span><span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>...</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="react-18-之后便不存在以上问题了"> React@18+之后便不存在以上问题了</h3>
<div><pre><code><span>import</span> <span>{</span> <span>FC</span><span>,</span> useEffect<span>,</span> useState <span>}</span> <span>from</span> <span>"react"</span><span>;</span>

<span>const</span> Increment<span>:</span> <span>FC</span><span>&lt;</span><span>any</span><span>></span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span>flag<span>,</span> setFlag<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>"[Incerment] Updated:"</span><span>,</span> count<span>,</span> flag<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>const</span> <span>incermentHandler</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>setCount</span><span>(</span><span>(</span>c<span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>
      <span>setFlag</span><span>(</span><span>(</span>f<span>)</span> <span>=></span> <span>!</span>f<span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>300</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>

  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>p</span><span>></span></span><span>Automatic Batching</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span>incermentHandler<span>}</span></span><span>></span></span><span>点击并查看console</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span></span><span>></span></span>
  <span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>export</span> <span>default</span> Increment<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>点击按钮后，你看到的是</p>
<div><pre><code><span>[</span>Incerment<span>]</span> <span>Updated:</span> <span>1</span> <span>true</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="react-18-过后flushsync又能做什么"> React 18 过后<code>flushSync</code>又能做什么</h4>
<p>现在使用 react18 可以开箱即用的实现<code>自动批更新</code>。但是我们确有需求在异步中提取更新啦？</p>
<div><pre><code><span>import</span> <span>{</span> <span>FC</span><span>,</span> useEffect<span>,</span> useState <span>}</span> <span>from</span> <span>"react"</span><span>;</span>
<span>import</span> ReactDOM <span>from</span> <span>"react-dom"</span><span>;</span>

<span>const</span> Increment<span>:</span> <span>FC</span><span>&lt;</span><span>any</span><span>></span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span>flag<span>,</span> setFlag<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>"[Increment] Updated:"</span><span>,</span> count<span>,</span> flag<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>const</span> <span>incermentHandler</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>setCount</span><span>(</span><span>(</span>c<span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>
<span>+</span>      ReactDOM<span>.</span><span>flushSync</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
<span>+</span>        <span>setFlag</span><span>(</span><span>(</span>f<span>)</span> <span>=></span> <span>!</span>f<span>)</span><span>;</span>
<span>+</span>      <span>}</span><span>)</span><span>;</span>
      <span>setCount</span><span>(</span><span>(</span>c<span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>300</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>

  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>p</span><span>></span></span><span>Automatic Batching</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span>incermentHandler<span>}</span></span><span>></span></span><span>点击并查看console</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span></span><span>></span></span>
  <span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>export</span> <span>default</span> Increment<span>;</span>

<span>// log</span>
<span>// [Increment] Updated: 0 true</span>
<span>// [Increment] Updated: 2 true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>这样，我们就可以同步更新<code>setFlag</code>了，即改变了更新级别。</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用memo或PureComponent前的思考</title>
      <link>https://kangduu.github.io/website/website/react/%E3%80%90%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%91%E4%BD%BF%E7%94%A8memo%E6%88%96PureComponent%E5%89%8D%E7%9A%84%E6%80%9D%E8%80%83.html</link>
      <guid>https://kangduu.github.io/website/website/react/%E3%80%90%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%91%E4%BD%BF%E7%94%A8memo%E6%88%96PureComponent%E5%89%8D%E7%9A%84%E6%80%9D%E8%80%83.html</guid>
      <source url="https://kangduu.github.io/website/website/rss.xml">使用memo或PureComponent前的思考</source>
      <category>React</category>
      <pubDate>Mon, 16 May 2022 14:56:12 GMT</pubDate>
      <content:encoded><![CDATA[<p>在我们编写 react 组件的时候，尽可能的拆分组件。而针对一些静态组件或没有 props 的组件，我们可以使用<code>React.memo</code>或者<code>React.useMemo</code>来避免不必要的更新。</p>
<p>###　一个渲染缓慢的组件</p>
<div><pre><code><span>import</span> <span>{</span> useState <span>}</span> <span>from</span> <span>"react"</span><span>;</span>

<span>function</span> <span>ExpensiveTree</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
  <span>while</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> now <span>&lt;</span> <span>100</span><span>)</span> <span>{</span>
    <span>// Artificial delay -- do nothing for 100ms</span>
  <span>}</span>
  <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>I am a very slow component tree.</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>
<span>}</span>

<span>const</span> <span>Demo</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>let</span> <span>[</span>color<span>,</span> setSolor<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>"red"</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>input</span>
        <span>type</span><span><span>=</span><span>"</span>color<span>"</span></span>
        <span>value</span><span><span>=</span><span>{</span>color<span>}</span></span>
        <span>onChange</span><span><span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=></span> <span>setSolor</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span></span>
        <span>style</span><span><span>=</span><span>{</span><span>{</span> <span>display</span><span>:</span> <span>"inline-block"</span><span>,</span> <span>marginLeft</span><span>:</span> <span>600</span> <span>}</span><span>}</span></span>
      <span>/></span></span><span>
      </span><span><span><span>&lt;</span>p</span> <span>style</span><span><span>=</span><span>{</span><span>{</span> color <span>}</span><span>}</span></span><span>></span></span><span>Hello, world!</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
      </span><span><span><span>&lt;</span><span>ExpensiveTree</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;/</span></span><span>></span></span>
  <span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>export</span> <span>default</span> Demo<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>现在我们来分析一波，在 App 组件中，当 color 改变时，导致 ExpensiveTree 组件也会更新。</p>
<p>遇到这种情况，我们第一反应是不是使用 <a href="https://react.docschina.org/docs/react-api.html#reactmemo" target="_blank" rel="noopener noreferrer">React.mmo</a>包装一下？或是将 class 组件改为<a href="https://react.docschina.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener noreferrer">React.PureComponent</a>继承啦？</p>
<div><pre><code><span>import</span> <span>{</span> memo<span>,</span> PureComponent <span>}</span> <span>from</span> <span>"react"</span><span>;</span>

<span>// 函数组件 使用memo</span>
<span>const</span> ExpensiveTree <span>=</span> <span>memo</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>let</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
  <span>while</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> now <span>&lt;</span> <span>100</span><span>)</span> <span>{</span>
    <span>// Artificial delay -- do nothing for 100ms</span>
  <span>}</span>
  <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>I am a very slow component tree.</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// class 组件 继承PureComponent</span>
<span>class</span> <span>ExpensiveTree</span> <span>extends</span> <span>PureComponent</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>I am a very slow component tree.</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>或许，我们应该从 React 本质来思考问题，我们写的组件还能不能再优化啦？</p>
<h3 id="解法一-向下移动-state"> 解法一：向下移动 state</h3>
<div><pre><code><span>import</span> <span>{</span> useState <span>}</span> <span>from</span> <span>"react"</span><span>;</span>

<span>const</span> ExpensiveTree <span>=</span> <span>memo</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>let</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
  <span>while</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> now <span>&lt;</span> <span>100</span><span>)</span> <span>{</span>
    <span>// Artificial delay -- do nothing for 100ms</span>
  <span>}</span>
  <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>I am a very slow component tree.</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// 向下移动State</span>
<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> <span>[</span>color<span>,</span> setSolor<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>"red"</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>input</span>
        <span>type</span><span><span>=</span><span>"</span>color<span>"</span></span>
        <span>value</span><span><span>=</span><span>{</span>color<span>}</span></span>
        <span>onChange</span><span><span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=></span> <span>setSolor</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span></span>
        <span>style</span><span><span>=</span><span>{</span><span>{</span> <span>display</span><span>:</span> <span>"inline-block"</span><span>,</span> <span>marginLeft</span><span>:</span> <span>600</span> <span>}</span><span>}</span></span>
      <span>/></span></span><span>
      </span><span><span><span>&lt;</span>p</span> <span>style</span><span><span>=</span><span>{</span><span>{</span> color <span>}</span><span>}</span></span><span>></span></span><span>Hello, world!</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span></span><span>></span></span>
  <span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>Demo</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span><span>App</span></span> <span>/></span></span><span>
      </span><span><span><span>&lt;</span><span>ExpensiveTree</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;/</span></span><span>></span></span>
  <span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>export</span> <span>default</span> Demo<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>当一部分 state 在高开销树的上层代码中使用时上述解法就无法奏效了。 比如，Demo 组件也需要 App 中的 color 状态，那这样便不可解决问题了？或者说又回到了 memo 和 PureComponent 上了啦？我们先来看看 Demo 组件的情况。</p>
<div><pre><code><span>const</span> <span>ExpensiveTree</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>let</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
  <span>while</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> now <span>&lt;</span> <span>100</span><span>)</span> <span>{</span>
    <span>// Artificial delay -- do nothing for 100ms</span>
  <span>}</span>
  <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>I am a very slow component tree.</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>
<span>}</span><span>;</span>

<span>const</span> <span>Demo</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>let</span> <span>[</span>color<span>,</span> setSolor<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>"red"</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span>div</span> <span>style</span><span><span>=</span><span>{</span><span>{</span> color <span>}</span><span>}</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>input</span>
        <span>type</span><span><span>=</span><span>"</span>color<span>"</span></span>
        <span>value</span><span><span>=</span><span>{</span>color<span>}</span></span>
        <span>onChange</span><span><span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=></span> <span>setSolor</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span></span>
        <span>style</span><span><span>=</span><span>{</span><span>{</span> <span>display</span><span>:</span> <span>"inline-block"</span><span>,</span> <span>marginLeft</span><span>:</span> <span>600</span> <span>}</span><span>}</span></span>
      <span>/></span></span><span>
      </span><span><span><span>&lt;</span>p</span> <span>style</span><span><span>=</span><span>{</span><span>{</span> color <span>}</span><span>}</span></span><span>></span></span><span>Hello, world!</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
      </span><span><span><span>&lt;</span><span>ExpensiveTree</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span>
  <span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="解法二-内容提升"> 解法二：内容提升</h3>
<div><pre><code><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>"react"</span><span>;</span>

<span>const</span> <span>ExpensiveTree</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>let</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
  <span>while</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> now <span>&lt;</span> <span>100</span><span>)</span> <span>{</span>
    <span>// Artificial delay -- do nothing for 100ms</span>
  <span>}</span>
  <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>I am a very slow component tree.</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>
<span>}</span><span>;</span>

<span>// 内容提升</span>
<span>function</span> <span>ColorPicker</span><span>(</span><span><span>{</span> children <span>}</span></span><span>)</span> <span>{</span>
  <span>let</span> <span>[</span>color<span>,</span> setSolor<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>"red"</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span>div</span> <span>style</span><span><span>=</span><span>{</span><span>{</span> color <span>}</span><span>}</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>input</span>
        <span>type</span><span><span>=</span><span>"</span>color<span>"</span></span>
        <span>value</span><span><span>=</span><span>{</span>color<span>}</span></span>
        <span>onChange</span><span><span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=></span> <span>setSolor</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span></span>
        <span>style</span><span><span>=</span><span>{</span><span>{</span> <span>display</span><span>:</span> <span>"inline-block"</span><span>,</span> <span>marginLeft</span><span>:</span> <span>600</span> <span>}</span><span>}</span></span>
      <span>/></span></span><span>
      </span><span><span><span>&lt;</span>p</span><span>></span></span><span>当前的字体颜色</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
      </span><span>{</span>children<span>}</span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span>
  <span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>Demo</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span><span>ColorPicker</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>p</span><span>></span></span><span>--父组件内容--</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
      </span><span><span><span>&lt;</span><span>ExpensiveTree</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;/</span><span>ColorPicker</span></span><span>></span></span>
  <span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>export</span> <span>default</span> Demo<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>ExpensiveTree 组件不会重新渲染的根本原因是，ColorPicker 组件中 color 改变后组件更新时 children 仍然保存着上一次从<code>Demo</code>中拿到的相同的<code>children</code>属性 。</p>
<h3 id="总结"> 总结</h3>
<p>React 组件的更新，只有 props 或 state 改变才会触发。</p>
<ul>
<li>
<p><a href="https://react.docschina.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener noreferrer">React.PureComponent</a></p>
</li>
<li>
<p><a href="https://react.docschina.org/docs/react-api.html#reactmemo" target="_blank" rel="noopener noreferrer">React.memo</a></p>
</li>
<li>
<h3 id="在你写-memo-之前"> <a href="https://overreacted.io/zh-hans/before-you-memo/" target="_blank" rel="noopener noreferrer">在你写 memo()之前</a></h3>
</li>
<li>
<p><a href="https://react.docschina.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener noreferrer">React.useMemo</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>React 进阶之“diff”算法</title>
      <link>https://kangduu.github.io/website/website/react/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91React%E8%BF%9B%E9%98%B6%E4%B9%8B%E2%80%9Cdiff%E2%80%9D%E7%AE%97%E6%B3%95.html</link>
      <guid>https://kangduu.github.io/website/website/react/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91React%E8%BF%9B%E9%98%B6%E4%B9%8B%E2%80%9Cdiff%E2%80%9D%E7%AE%97%E6%B3%95.html</guid>
      <source url="https://kangduu.github.io/website/website/rss.xml">React 进阶之“diff”算法</source>
      <category>React</category>
      <pubDate>Mon, 16 May 2022 14:56:12 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="react-进阶之-diff-算法"> React 进阶之“diff”算法</h1>
<h3 id="react-元素的-key-属性有什么作用"> React 元素的 key 属性有什么作用？</h3>
<p>这是一道面试必问题，面试中你是如何回答这个问题的啦。从面试的角度来思考这个问题，面试官最想知道的是你是否对 React 底层原理有一定的了解。这个问题先记下来，我们先对<code>React的“diffing”算法</code>进行深入探讨，再回过头来回答这个问题。</p>
]]></content:encoded>
    </item>
    <item>
      <title>你对 react-fiber 有了解吗？</title>
      <link>https://kangduu.github.io/website/website/react/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91fiber.html</link>
      <guid>https://kangduu.github.io/website/website/react/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91fiber.html</guid>
      <source url="https://kangduu.github.io/website/website/rss.xml">你对 react-fiber 有了解吗？</source>
      <category>React</category>
      <pubDate>Mon, 16 May 2022 14:56:12 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="你对-react-fiber-有了解吗"> 你对 react-fiber 有了解吗？</h2>
<ol>
<li>对于 react 原理的了解。</li>
<li>对于新技术的敏感程度，求知欲。</li>
</ol>
<h3 id="目的"> 目的</h3>
<ul>
<li>为了使 react 渲染的过程可以被<strong>中断</strong>，可以将控制权交还给浏览器，可以让位给<strong>高优先级的任务</strong>，浏览器空闲后再恢复渲染。</li>
<li>对于计算量比较大的 js 计算或者 dom 计算，就不会显得特别的卡顿，而是一帧一帧的有规律的执行任务。</li>
</ul>
<p>🌰 中断</p>
<div><pre><code><span>const</span> tasks <span>=</span> <span>[</span><span>]</span><span>;</span> <span>// 多个任务 同步</span>

<span>function</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> task<span>;</span>
  <span>while</span> <span>(</span><span>(</span>task <span>=</span> tasks<span>.</span><span>shift</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>
    <span>execute</span><span>(</span>task<span>)</span><span>;</span> <span>// 这里执行execute需要5秒左右时间</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这种就会存在一个问题，每一个任务都需要大约 5 秒时间，那就会导致阻塞。
如果在某个任务处停止啦？</p>
<h3 id="使用-generator-模拟中断"> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="noopener noreferrer">使用 generator 模拟中断</a></h3>
<div><pre><code><span>const</span> tasks <span>=</span> <span>[</span><span>]</span><span>;</span> <span>// 多个任务 同步</span>

<span>function</span><span>*</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> task<span>;</span>
  <span>while</span> <span>(</span><span>(</span>task <span>=</span> tasks<span>.</span><span>shift</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>hasHighPriorityTask</span><span>(</span><span>)</span><span>)</span> <span>{</span>
      <span>yield</span><span>;</span>
    <span>}</span>
    <span>execute</span><span>(</span>task<span>)</span><span>;</span> <span>// 这里执行execute需要5秒左右时间</span>
  <span>}</span>
<span>}</span>

<span>const</span> iterator <span>=</span> <span>run</span><span>(</span><span>)</span><span>;</span>

<span>// 恢复</span>
iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>上边的代码简单的实现了中断任务并可恢复。</p>
<p><strong>🤔Question：</strong> 既然 generator 有类似的功能，为什么 react 不用 啦？</p>
<ol>
<li>
<p>需要用 generator 将涉及到的所有的代码都包装成 generator * 形式，非常麻烦，工作量比较大。</p>
</li>
<li>
<p>generator 内部是有状态的</p>
</li>
</ol>
<div><pre><code><span>function</span><span>*</span> <span>doWork</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>
  <span>const</span> x <span>=</span> <span>doExpensiveWorkA</span><span>(</span>a<span>)</span><span>;</span> <span>// x的值依赖a</span>
  <span>yield</span><span>;</span>
  <span>const</span> y <span>=</span> <span>doExpensiveWorkA</span><span>(</span>x<span>,</span> b<span>)</span><span>;</span> <span>// 依赖x的值</span>
  <span>return</span> y<span>;</span>
<span>}</span>
<span>// 假设doExpensiveWorkA作用是将传入的参数相加后并返回结果。</span>
<span>let</span> m <span>=</span> <span>1</span><span>,</span>
  n <span>=</span> <span>2</span><span>;</span>
<span>const</span> working <span>=</span> <span>doWork</span><span>(</span>m<span>,</span> n<span>)</span><span>;</span>
working<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span> <span>// x = m = 1</span>

m <span>=</span> <span>4</span><span>;</span> <span>//如果这里改变了m，但是x已经done了，所以我们只能沿用旧的x值。</span>
working<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span> <span>// y = x + b = a + b = m + n;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="如何判断当前是否有高优先级任务"> 如何判断当前是否有高优先级任务？</h3>
<p>首先我们需要明白的是，当前 js 的环境其实并没有办法去判断是否有高优任务。<strong>🤔Question：</strong> 那你会怎么实现或者模拟一个啦？</p>
<ul>
<li>
<p>只能约定一个合理的执行时间，当超过这个执行时间，如果任务任然没有执行完成，那就中断当前任务，将控制权交还给浏览器。</p>
<p>普遍的显示器都是每秒 60 帧，<strong>1000ms / 60fps = 16ms</strong>。大概就是一帧的时间大约是 16 毫秒。</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener noreferrer">requestIdleCallback(callback[, options])</a> : callback 函数将在<strong>浏览器空闲时期</strong>被调用。</p>
<p>并且 callback 函数会接收到一个名为 IdleDeadline 的参数，这个参数可以获取当前空闲时间以及回调是否在超时时间前已经执行的状态。</p>
</li>
<li>
<p>浏览器在一帧内要做什么事情？</p>
<ol>
<li>处理用户输入事件</li>
<li>JS 的执行</li>
<li>requestAnimation 调用</li>
<li>布局 layout</li>
<li>绘制 paint</li>
</ol>
<blockquote>
<p>16ms 一帧时间内，浏览器就没有空闲时间，
即 0ms -&gt; requestIdleCallback 将没有时间被调用
那一直都没有空闲时间啦？</p>
</blockquote>
</li>
<li>
<p>浏览器很忙怎么办？（空闲时间为 0）</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener noreferrer">requestIdleCallback(callback[, options])</a> 第二个参数 <strong>{ timeout: 100 }</strong></p>
<div><pre><code>window<span>.</span><span>requestIdleCallback</span><span>(</span>
  <span>(</span><span>args</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>args<span>)</span><span>;</span>
  <span>}</span><span>,</span>
  <span>{</span>
    <span>timeout</span><span>:</span> <span>100</span><span>,</span>
    <span>//如果指定了timeout，并且有一个正值，而回调在timeout毫秒过后还没有被调用，那么回调任务将放入事件循环中排队，即使这样做有可能对性能产生负面影响。</span>
  <span>}</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p><a href="https://caniuse.com/?search=requestIdleCallback" target="_blank" rel="noopener noreferrer">requestIdelCallback 的兼容性</a> 很差</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="说说-react-是如何实现-requestidlecallback-的"> 说说 react 是如何实现 requestIdleCallback 的？</h2>
<blockquote>
<p>通过 messageChannel 模拟实现</p>
</blockquote>
<h2 id="react-中的任务优先级"> react 中的任务优先级？</h2>
<p>5 个优先级：</p>
<ol>
<li><strong>Immediate</strong> 最高优先级，这个优先级的任务应该马上被执行，且不能中断；</li>
<li><strong>UserBlocking</strong> 这些任务一般是用户交互的结果，需要及时得到反馈；</li>
<li><strong>Normal</strong> 不需要用户立刻能感受到的变化，比如网络请求等；</li>
<li><strong>Low</strong> 这些任务可以被延后，但是最终也需要被执行；</li>
<li><strong>Idle</strong> 可以被无限期延后，比如 console</li>
</ol>
<blockquote>
<blockquote>
<blockquote>
<p>同一级别的任务，先后顺序</p>
</blockquote>
</blockquote>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>首页</title>
      <link>https://kangduu.github.io/website/website/</link>
      <guid>https://kangduu.github.io/website/website/</guid>
      <source url="https://kangduu.github.io/website/website/rss.xml">首页</source>
      <pubDate>Fri, 29 Apr 2022 09:54:32 GMT</pubDate>
    </item>
    <item>
      <title>TypeScript Syntax</title>
      <link>https://kangduu.github.io/website/website/typescript/</link>
      <guid>https://kangduu.github.io/website/website/typescript/</guid>
      <source url="https://kangduu.github.io/website/website/rss.xml">TypeScript Syntax</source>
      <description>TypeScript is a strongly typed programming language that builds on JavaScript, giving you better tooling at any scale.</description>
      <category>React</category>
      <pubDate>Thu, 05 May 2022 10:01:30 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="阅读角"> 阅读角</h1>
<ul>
<li><a href="https://ts.yayujs.com/" target="_blank" rel="noopener noreferrer">TypeScript-yy</a></li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>
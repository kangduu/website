{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "大眼猫看前端",
  "home_page_url": "https://kangduu.github.io/website/website/",
  "feed_url": "https://kangduu.github.io/website/website/feed.json",
  "description": "HTML、CSS、JavaScript、TypeScript、React、Vue...",
  "author": {
    "name": "大眼猫"
  },
  "items": [
    {
      "title": "React 系列文章",
      "url": "https://kangduu.github.io/website/website/case/",
      "id": "https://kangduu.github.io/website/website/case/",
      "content_html": "<h1 id=\"react-系列文章\"> React 系列文章</h1>\n",
      "date_published": "2022-05-05T10:01:30.000Z",
      "date_modified": "2022-05-05T10:01:30.000Z",
      "authors": [
        {
          "name": "大眼猫"
        }
      ],
      "tags": []
    },
    {
      "title": "Frond End Interview",
      "url": "https://kangduu.github.io/website/website/interview/",
      "id": "https://kangduu.github.io/website/website/interview/",
      "content_html": "<GithubIssueList />\n",
      "date_published": "2022-05-05T10:01:30.000Z",
      "date_modified": "2022-05-16T15:32:02.000Z",
      "authors": [
        {
          "name": "大眼猫"
        }
      ],
      "tags": [
        "interview"
      ]
    },
    {
      "title": "React高阶组件（HOC）",
      "url": "https://kangduu.github.io/website/website/react/HOC.html",
      "id": "https://kangduu.github.io/website/website/react/HOC.html",
      "content_html": "<ol>\n<li></li>\n<li>有几种高阶组件（实现）？各种的优缺点是什么？</li>\n<li>你平时是如何写高阶组件的？</li>\n<li>HOC 怎么处理静态属性、跨层级 ref 等问题？</li>\n<li>高阶组件怎么控制渲染？隔离渲染？</li>\n<li>高阶组件如何监视原始组件状态？</li>\n</ol>\n<h2 id=\"什么是高阶组件\"> 什么是高阶组件？</h2>\n<p><a href=\"https://react.docschina.org/docs/higher-order-components.html\" target=\"_blank\" rel=\"noopener noreferrer\">🙋 高阶组件</a> 是 <strong>参数为组件</strong>，<strong>返回值为新组件</strong> 的 <strong>函数</strong></p>\n<div><pre><code><span>const</span> EnhancedComponent <span>=</span> <span>higherOrderComponent</span><span>(</span>WrappedComponent<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>🤔 <strong>Questions：</strong> 高阶组件与组件之间的差别是什么？</p>\n<p>🙋 <strong>Answer：</strong> 组件是将 props 和 state 转化为 UI，而高阶组件是将组件转换为另一个组件。</p>\n<p>为了后期维护方便。<u>最好是一个纯函数，尽量不要有副作用。</u></p>\n<h2 id=\"高阶组件解决了哪些问题-高阶组件产生的初衷\"> 高阶组件解决了哪些问题？（高阶组件产生的初衷？）</h2>\n<ol>\n<li>逻辑复用</li>\n<li>props 强化</li>\n<li>组件赋能</li>\n<li>控制渲染</li>\n</ol>\n<p>🤔 <strong>思考：</strong> 在没有高阶组件之前，又是如何处理这些问题的啦？</p>\n<h2 id=\"如何优雅的写一个高阶组件\"> 如何优雅的写一个高阶组件？</h2>\n<ol>\n<li>普通模式</li>\n<li>装饰器</li>\n<li>多高阶组件组合</li>\n</ol>\n<h2 id=\"高阶组件能用来做什么\"> 高阶组件能用来做什么？</h2>\n<h2 id=\"说说我们平时使用的轮子中使用了-hoc-技术的有哪些啦\"> 说说我们平时使用的轮子中使用了 HOC 技术的有哪些啦？</h2>\n<blockquote>\n<p>Redux 中的 <code>connect()</code></p>\n<p>React Router 中的 <code>withRoute</code></p>\n<p>Relay 中的 <code>createFragmentContainer</code></p>\n</blockquote>\n<h2 id=\"总结\"> 总结</h2>\n<h2 id=\"参考文献\"> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6940422320427106335\" target=\"_blank\" rel=\"noopener noreferrer\">「react 进阶」一文吃透 React 高阶组件(HOC)</a></li>\n<li><a href=\"https://juejin.cn/post/6844904050236850184\" target=\"_blank\" rel=\"noopener noreferrer\">React 高阶组件(HOC)的入门 📖 及实践 💻</a></li>\n</ul>\n",
      "date_published": "2022-05-16T14:56:12.000Z",
      "date_modified": "2022-05-16T14:56:12.000Z",
      "authors": [
        {
          "name": "大眼猫"
        }
      ],
      "tags": [
        "React"
      ]
    },
    {
      "title": "深入浅出 React 系列",
      "url": "https://kangduu.github.io/website/website/react/",
      "id": "https://kangduu.github.io/website/website/react/",
      "summary": "用于构建用户界面的 JavaScript 库",
      "content_html": "\n<div><p>提示</p>\n<p>这是一个提示</p>\n</div>\n<div><p>注意</p>\n<p>这是一个警告</p>\n</div>\n<div><p>警告</p>\n<p>这是一个危险警告</p>\n</div>\n<details><summary>DETAILS</summary>\n<p>这是一个详情块，在 Internet Explorer / Edge 中不生效</p>\n</details>\n<h3 id=\"react-组件模式\"> React 组件模式</h3>\n<h3 id=\"阅读角\"> 阅读角</h3>\n<ul>\n<li><a href=\"https://overreacted.io/\" target=\"_blank\" rel=\"noopener noreferrer\">overreacted</a></li>\n<li><a href=\"https://www.30secondsofcode.org/react/p/1\" target=\"_blank\" rel=\"noopener noreferrer\">30 seconds of code with react</a></li>\n<li><a href=\"https://ahooks.js.org/zh-CN\" target=\"_blank\" rel=\"noopener noreferrer\">ahooks</a></li>\n</ul>\n",
      "date_published": "2022-05-05T10:01:30.000Z",
      "date_modified": "2022-05-16T15:32:02.000Z",
      "authors": [
        {
          "name": "大眼猫"
        }
      ],
      "tags": [
        "React"
      ]
    },
    {
      "title": "官方文档",
      "url": "https://kangduu.github.io/website/website/react/useEffect%E5%92%8CuseLayoutEffect%E7%9A%84%E5%8C%BA%E5%88%AB.html",
      "id": "https://kangduu.github.io/website/website/react/useEffect%E5%92%8CuseLayoutEffect%E7%9A%84%E5%8C%BA%E5%88%AB.html",
      "content_html": "<h2 id=\"官方文档\"> 官方文档</h2>\n<h3 id=\"useeffect\"> useEffect</h3>\n<div><pre><code><span>useEffect</span><span>(</span>didUpdate<span>[</span><span>,</span><span>[</span>dep<span>]</span><span>]</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><ol>\n<li>\n<p>赋值给 <code>useEffect</code> 的函数 didUpdate 会在<u>组件渲染到屏幕之后</u>执行。 即待浏览器完成画面渲染之后才会延迟调用 <code>useEffect</code> 。</p>\n</li>\n<li>\n<p>清除函数（didUpdate的返回值）。 为防止内存泄漏，清除函数会<u>在组件卸载前执行</u>。  如果组件多次渲染（通常如此），则<strong>在执行下一个 effect 之前，上一个 effect 就已被清除</strong>。</p>\n<div><pre><code>useEffect(() =&gt; {\n  const subscription = props.source.subscribe();\n  return () =&gt; {\n    // 清除订阅\n    subscription.unsubscribe();\n  };\n});\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>\n<li>\n<p>与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 不同的是，在浏览器完成布局与绘制<strong>之后</strong>，传给 <code>useEffect</code> 的函数<u>会延迟调用</u>。</p>\n</li>\n<li>\n<p>虽然 <code>useEffect</code> 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。</p>\n</li>\n</ol>\n<p>详见<a href=\"https://react.docschina.org/docs/hooks-reference.html#useeffect\" target=\"_blank\" rel=\"noopener noreferrer\">useLayoutEffect</a></p>\n<h3 id=\"uselayouteffect\"> useLayoutEffect</h3>\n<div><pre><code>useLayoutEffect(didUpdate[,[dep]]);\n</code></pre>\n<div><span>1</span><br></div></div><p>​\t\t其函数签名与 <code>useEffect</code> 相同，但它<u>会在所有的 DOM 变更之后同步调用 effect</u>。可以使用它来<u><strong>读取 DOM 布局并同步触发重渲染</strong></u>。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p>\n<p>​\t\t尽可能使用标准的 useEffect 以避免阻塞视觉更新。</p>\n<blockquote>\n<p><strong>提示</strong></p>\n<p>如果你正在将代码从 class 组件迁移到使用 Hook 的函数组件，则<u>需要注意 <code>useLayoutEffect</code> 与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 的调用阶段是一样的</u>。但是，我们推荐你<strong>一开始先用 <code>useEffect</code></strong>，只有当它出问题的时候再尝试使用 <code>useLayoutEffect</code>。</p>\n<p>......服务端渲染相关内容，详见<a href=\"https://react.docschina.org/docs/hooks-reference.html#uselayouteffect\" target=\"_blank\" rel=\"noopener noreferrer\">useLayoutEffect</a></p>\n</blockquote>\n<h2 id=\"最大的不同\"> 最大的不同</h2>\n<p><strong>调用时机的不同</strong></p>\n<ol>\n<li><code>useLayoutEffect</code> 与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 的调用阶段是一样的。</li>\n<li>在浏览器完成布局与绘制<strong>之后</strong>，传给 <code>useEffect</code> 的函数会延迟调用。</li>\n</ol>\n<p>🌰举例说明useEffect和useLayoutEffect的调用时机不同：</p>\n<div><pre><code><span>// Parent.jsx</span>\n<span>import</span> React<span>,</span> <span>{</span> Component <span>}</span> <span>from</span> <span>\"react\"</span><span>;</span>\n<span>import</span> Child <span>from</span> <span>\"./Child\"</span><span>;</span>\n<span>export</span> <span>default</span> <span>class</span> <span>Parent</span> <span>extends</span> <span>Component</span> <span>{</span>\n  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>\"[Parent] componentDidMount\"</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span><span><span>&lt;</span><span>Child</span></span> <span>/></span></span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// Child.jsx</span>\n<span>import</span> React<span>,</span> <span>{</span> useEffect<span>,</span> useLayoutEffect <span>}</span> <span>from</span> <span>\"react\"</span><span>;</span>\n<span>export</span> <span>default</span> <span>function</span> <span>Test</span><span>(</span><span>)</span> <span>{</span>\n  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>\"[Child] useEffect mount\"</span><span>)</span><span>;</span>\n  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>\n  <span>useLayoutEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>\"[Child] useLayoutEffect mount\"</span><span>)</span><span>;</span>\n  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>\n  <span>return</span> <span><span><span>&lt;</span>div</span><span>></span></span><span>Child</span><span><span><span>&lt;/</span>div</span><span>></span></span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>🙋 <em><strong>Answer：</strong></em> 上述案例的日志结果如下。</p>\n<div><pre><code>[Child] useLayoutEffect mount   // 子组件挂载完成\n[Parent] componentDidMount\t\t// 父组件挂载完成\n[Child] useEffect mount\t\t\t// useEffect延迟调用了\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"什么情况下使用uselayouteffect\"> 什么情况下使用useLayoutEffect？</h2>\n<p>在浏览器执行下一次绘制前，用户可见的 DOM 变更必须同步执行，这样用户才不会感觉到视觉上的不一致 。</p>\n",
      "date_published": "2022-05-16T14:56:12.000Z",
      "date_modified": "2022-05-16T14:56:12.000Z",
      "authors": [
        {
          "name": "大眼猫"
        }
      ],
      "tags": []
    },
    {
      "title": "React@18 新特性",
      "url": "https://kangduu.github.io/website/website/react/%E3%80%90React_V18%E3%80%91react@18+%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html",
      "id": "https://kangduu.github.io/website/website/react/%E3%80%90React_V18%E3%80%91react@18+%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html",
      "content_html": "<h3 id=\"react-18\"> React 18</h3>\n<ul>\n<li>\n<p><a href=\"./[性能优化]React.flushSync处理异步批量setState导致多次更新.html\">Automatic batching 自动批处理</a></p>\n</li>\n<li>\n<p>New APIS</p>\n<ul>\n<li>concurrent features\n<ul>\n<li><a href=\"https://reactjs.org/docs/react-api.html#starttransition\" target=\"_blank\" rel=\"noopener noreferrer\">React.startTransition()</a></li>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html#usedeferredvalue\" target=\"_blank\" rel=\"noopener noreferrer\">useDeferredValue()</a></li>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html#usetransition\" target=\"_blank\" rel=\"noopener noreferrer\">useTransition()</a></li>\n</ul>\n</li>\n<li>mostly for libraries\n<ul>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html#useid\" target=\"_blank\" rel=\"noopener noreferrer\">useId()</a></li>\n<li><a href=\"https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore\" target=\"_blank\" rel=\"noopener noreferrer\">useSyncExternalStore()</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Suspense on the server</p>\n</li>\n</ul>\n<h3 id=\"react-dom-18\"> react-dom 18</h3>\n<ul>\n<li>New Render API\n<ul>\n<li><a href=\"https://reactjs.org/docs/react-dom-client.html#createroot\" target=\"_blank\" rel=\"noopener noreferrer\">ReactDOM.createRoot</a>:需要将<code>ReactDOM.render</code>切换到<code>ReactDOM。createRoot</code></li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://www.youtube.com/watch?v=ytudH8je5ko\" target=\"_blank\" rel=\"noopener noreferrer\">官方演示视频</a></p>\n",
      "date_published": "2022-05-16T14:56:12.000Z",
      "date_modified": "2022-05-16T14:56:12.000Z",
      "authors": [
        {
          "name": "大眼猫"
        }
      ],
      "tags": [
        "React"
      ]
    },
    {
      "title": "Automatic Batching Update",
      "url": "https://kangduu.github.io/website/website/react/%E3%80%90%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%91React.flushSync%E4%B8%8EAutomaticBatching.html",
      "id": "https://kangduu.github.io/website/website/react/%E3%80%90%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%91React.flushSync%E4%B8%8EAutomaticBatching.html",
      "content_html": "<h1 id=\"automatic-batching-update\"> Automatic Batching Update</h1>\n<h3 id=\"react-是如何进行自动批处理更新的\"> React 是如何进行自动批处理更新的？</h3>\n<p><strong>在 React@18.0.0之前</strong>，我们使用 setState 或者 Hook 修改状态后，并不会立即触发重新渲染。React 会执行全部事件处理函数，然后触发一个单独的 re-render，<strong>合并所有更新</strong>。 <em>—— tips：只能处理同步任务</em></p>\n<p>🌰 写一个案例，实现<strong>多次</strong>同步调用 setState 或 hooks</p>\n<div><pre><code><span>import</span> <span>{</span> useEffect<span>,</span> useState <span>}</span> <span>from</span> <span>\"react\"</span><span>;</span>\n\n<span>const</span> <span>Increment</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>\n\n  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span><span>\"count value:\"</span><span>,</span> count<span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n\n  <span>const</span> <span>incermentHandler</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>\n    <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>\n    <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>\n  <span>}</span><span>;</span>\n\n  <span>return</span> <span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span>incermentHandler<span>}</span></span><span>></span></span><span>点击</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>export</span> <span>default</span> Increment<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>当我们点击按钮后，控制台应该打印什么日志信息啦？</p>\n<div><pre><code>count value<span>:</span> <span>1</span>\ncount value<span>:</span> <span>2</span>\ncount value<span>:</span> <span>3</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>是这样吗？并不是。</p>\n<p>正确结果：</p>\n<div><pre><code><span>count value:</span> <span>3</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>🌰 同样的代码，修改一下处理函数调用 setState 或 hooks 的方式。</p>\n<div><pre><code><span>...</span>\n\n<span>const</span> <span>incermentHandler</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span> <span>// Promise Ajax ...</span>\n        <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>\n        <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>\n        <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span> <span>300</span><span>)</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果你像上面这样更新状态，console 日志信息打印结果？</p>\n<div><pre><code>count value<span>:</span> <span>1</span>\ncount value<span>:</span> <span>2</span>\ncount value<span>:</span> <span>3</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>是的，就是更新了三次。意不意外，惊不惊喜！</p>\n<p>还记得一开始我们说的吗？合并所有更新，只能是同步的任务。</p>\n<p>那我们就不能在异步任务中多次修改 state 了吗？完全可以，而且也可以只更新一次。</p>\n<h3 id=\"使用reactdom-flushsync解决异步多次修改状态导致多次更新的问题\"> 使用<code>ReactDOM.flushSync</code>解决异步多次修改状态导致多次更新的问题</h3>\n<div><pre><code><span>// flushSync</span>\n<span>export</span> <span>function</span> <span><span>flushSync</span><span><span>&lt;</span><span>R</span><span>></span></span></span><span>(</span><span>fn</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>R</span><span>)</span><span>:</span> <span>R</span><span>;</span>\n<span>export</span> <span>function</span> <span><span>flushSync</span><span><span>&lt;</span><span>A</span><span>,</span> <span>R</span><span>></span></span></span><span>(</span><span>fn</span><span>:</span> <span>(</span>a<span>:</span> <span>A</span><span>)</span> <span>=></span> <span>R</span><span>,</span> a<span>:</span> <span>A</span><span>)</span><span>:</span> <span>R</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>import</span> ReactDOM <span>from</span> <span>\"react-dom\"</span><span>;</span>\n\n<span>...</span>\n\n<span>const</span> <span>incermentHandler</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n<span>+</span>        ReactDOM<span>.</span><span>flushSync</span><span>(</span><span>(</span><span>)</span><span>=></span><span>{</span>\n            <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>\n            <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>\n            <span>setCount</span><span>(</span><span>(</span><span>c</span><span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>\n<span>+</span>        <span>}</span><span>)</span>\n    <span>}</span><span>,</span> <span>300</span><span>)</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>...</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"react-18-之后便不存在以上问题了\"> React@18+之后便不存在以上问题了</h3>\n<div><pre><code><span>import</span> <span>{</span> <span>FC</span><span>,</span> useEffect<span>,</span> useState <span>}</span> <span>from</span> <span>\"react\"</span><span>;</span>\n\n<span>const</span> Increment<span>:</span> <span>FC</span><span>&lt;</span><span>any</span><span>></span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>\n  <span>const</span> <span>[</span>flag<span>,</span> setFlag<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>\n\n  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>\"[Incerment] Updated:\"</span><span>,</span> count<span>,</span> flag<span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n\n  <span>const</span> <span>incermentHandler</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>setCount</span><span>(</span><span>(</span>c<span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>\n      <span>setFlag</span><span>(</span><span>(</span>f<span>)</span> <span>=></span> <span>!</span>f<span>)</span><span>;</span>\n    <span>}</span><span>,</span> <span>300</span><span>)</span><span>;</span>\n  <span>}</span><span>;</span>\n\n  <span>return</span> <span>(</span>\n    <span><span><span>&lt;</span></span><span>></span></span><span>\n      </span><span><span><span>&lt;</span>p</span><span>></span></span><span>Automatic Batching</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>\n      </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span>incermentHandler<span>}</span></span><span>></span></span><span>点击并查看console</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>\n    </span><span><span><span>&lt;/</span></span><span>></span></span>\n  <span>)</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>export</span> <span>default</span> Increment<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>点击按钮后，你看到的是</p>\n<div><pre><code><span>[</span>Incerment<span>]</span> <span>Updated:</span> <span>1</span> <span>true</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"react-18-过后flushsync又能做什么\"> React 18 过后<code>flushSync</code>又能做什么</h4>\n<p>现在使用 react18 可以开箱即用的实现<code>自动批更新</code>。但是我们确有需求在异步中提取更新啦？</p>\n<div><pre><code><span>import</span> <span>{</span> <span>FC</span><span>,</span> useEffect<span>,</span> useState <span>}</span> <span>from</span> <span>\"react\"</span><span>;</span>\n<span>import</span> ReactDOM <span>from</span> <span>\"react-dom\"</span><span>;</span>\n\n<span>const</span> Increment<span>:</span> <span>FC</span><span>&lt;</span><span>any</span><span>></span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>\n  <span>const</span> <span>[</span>flag<span>,</span> setFlag<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>\n\n  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>\"[Increment] Updated:\"</span><span>,</span> count<span>,</span> flag<span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n\n  <span>const</span> <span>incermentHandler</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n      <span>setCount</span><span>(</span><span>(</span>c<span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>\n<span>+</span>      ReactDOM<span>.</span><span>flushSync</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n<span>+</span>        <span>setFlag</span><span>(</span><span>(</span>f<span>)</span> <span>=></span> <span>!</span>f<span>)</span><span>;</span>\n<span>+</span>      <span>}</span><span>)</span><span>;</span>\n      <span>setCount</span><span>(</span><span>(</span>c<span>)</span> <span>=></span> c <span>+</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span><span>,</span> <span>300</span><span>)</span><span>;</span>\n  <span>}</span><span>;</span>\n\n  <span>return</span> <span>(</span>\n    <span><span><span>&lt;</span></span><span>></span></span><span>\n      </span><span><span><span>&lt;</span>p</span><span>></span></span><span>Automatic Batching</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>\n      </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span>incermentHandler<span>}</span></span><span>></span></span><span>点击并查看console</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>\n    </span><span><span><span>&lt;/</span></span><span>></span></span>\n  <span>)</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>export</span> <span>default</span> Increment<span>;</span>\n\n<span>// log</span>\n<span>// [Increment] Updated: 0 true</span>\n<span>// [Increment] Updated: 2 true</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>这样，我们就可以同步更新<code>setFlag</code>了，即改变了更新级别。</p>\n",
      "date_published": "2022-05-16T14:56:12.000Z",
      "date_modified": "2022-05-16T14:56:12.000Z",
      "authors": [
        {
          "name": "大眼猫"
        }
      ],
      "tags": [
        "React"
      ]
    },
    {
      "title": "使用memo或PureComponent前的思考",
      "url": "https://kangduu.github.io/website/website/react/%E3%80%90%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%91%E4%BD%BF%E7%94%A8memo%E6%88%96PureComponent%E5%89%8D%E7%9A%84%E6%80%9D%E8%80%83.html",
      "id": "https://kangduu.github.io/website/website/react/%E3%80%90%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%91%E4%BD%BF%E7%94%A8memo%E6%88%96PureComponent%E5%89%8D%E7%9A%84%E6%80%9D%E8%80%83.html",
      "content_html": "<p>在我们编写 react 组件的时候，尽可能的拆分组件。而针对一些静态组件或没有 props 的组件，我们可以使用<code>React.memo</code>或者<code>React.useMemo</code>来避免不必要的更新。</p>\n<p>###　一个渲染缓慢的组件</p>\n<div><pre><code><span>import</span> <span>{</span> useState <span>}</span> <span>from</span> <span>\"react\"</span><span>;</span>\n\n<span>function</span> <span>ExpensiveTree</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>\n  <span>while</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> now <span>&lt;</span> <span>100</span><span>)</span> <span>{</span>\n    <span>// Artificial delay -- do nothing for 100ms</span>\n  <span>}</span>\n  <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>I am a very slow component tree.</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>\n<span>}</span>\n\n<span>const</span> <span>Demo</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>let</span> <span>[</span>color<span>,</span> setSolor<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>\"red\"</span><span>)</span><span>;</span>\n  <span>return</span> <span>(</span>\n    <span><span><span>&lt;</span></span><span>></span></span><span>\n      </span><span><span><span>&lt;</span>input</span>\n        <span>type</span><span><span>=</span><span>\"</span>color<span>\"</span></span>\n        <span>value</span><span><span>=</span><span>{</span>color<span>}</span></span>\n        <span>onChange</span><span><span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=></span> <span>setSolor</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span></span>\n        <span>style</span><span><span>=</span><span>{</span><span>{</span> <span>display</span><span>:</span> <span>\"inline-block\"</span><span>,</span> <span>marginLeft</span><span>:</span> <span>600</span> <span>}</span><span>}</span></span>\n      <span>/></span></span><span>\n      </span><span><span><span>&lt;</span>p</span> <span>style</span><span><span>=</span><span>{</span><span>{</span> color <span>}</span><span>}</span></span><span>></span></span><span>Hello, world!</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>\n      </span><span><span><span>&lt;</span><span>ExpensiveTree</span></span> <span>/></span></span><span>\n    </span><span><span><span>&lt;/</span></span><span>></span></span>\n  <span>)</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>export</span> <span>default</span> Demo<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>现在我们来分析一波，在 App 组件中，当 color 改变时，导致 ExpensiveTree 组件也会更新。</p>\n<p>遇到这种情况，我们第一反应是不是使用 <a href=\"https://react.docschina.org/docs/react-api.html#reactmemo\" target=\"_blank\" rel=\"noopener noreferrer\">React.mmo</a>包装一下？或是将 class 组件改为<a href=\"https://react.docschina.org/docs/react-api.html#reactpurecomponent\" target=\"_blank\" rel=\"noopener noreferrer\">React.PureComponent</a>继承啦？</p>\n<div><pre><code><span>import</span> <span>{</span> memo<span>,</span> PureComponent <span>}</span> <span>from</span> <span>\"react\"</span><span>;</span>\n\n<span>// 函数组件 使用memo</span>\n<span>const</span> ExpensiveTree <span>=</span> <span>memo</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>let</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>\n  <span>while</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> now <span>&lt;</span> <span>100</span><span>)</span> <span>{</span>\n    <span>// Artificial delay -- do nothing for 100ms</span>\n  <span>}</span>\n  <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>I am a very slow component tree.</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>// class 组件 继承PureComponent</span>\n<span>class</span> <span>ExpensiveTree</span> <span>extends</span> <span>PureComponent</span> <span>{</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>I am a very slow component tree.</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>或许，我们应该从 React 本质来思考问题，我们写的组件还能不能再优化啦？</p>\n<h3 id=\"解法一-向下移动-state\"> 解法一：向下移动 state</h3>\n<div><pre><code><span>import</span> <span>{</span> useState <span>}</span> <span>from</span> <span>\"react\"</span><span>;</span>\n\n<span>const</span> ExpensiveTree <span>=</span> <span>memo</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>let</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>\n  <span>while</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> now <span>&lt;</span> <span>100</span><span>)</span> <span>{</span>\n    <span>// Artificial delay -- do nothing for 100ms</span>\n  <span>}</span>\n  <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>I am a very slow component tree.</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>// 向下移动State</span>\n<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> <span>[</span>color<span>,</span> setSolor<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>\"red\"</span><span>)</span><span>;</span>\n  <span>return</span> <span>(</span>\n    <span><span><span>&lt;</span></span><span>></span></span><span>\n      </span><span><span><span>&lt;</span>input</span>\n        <span>type</span><span><span>=</span><span>\"</span>color<span>\"</span></span>\n        <span>value</span><span><span>=</span><span>{</span>color<span>}</span></span>\n        <span>onChange</span><span><span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=></span> <span>setSolor</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span></span>\n        <span>style</span><span><span>=</span><span>{</span><span>{</span> <span>display</span><span>:</span> <span>\"inline-block\"</span><span>,</span> <span>marginLeft</span><span>:</span> <span>600</span> <span>}</span><span>}</span></span>\n      <span>/></span></span><span>\n      </span><span><span><span>&lt;</span>p</span> <span>style</span><span><span>=</span><span>{</span><span>{</span> color <span>}</span><span>}</span></span><span>></span></span><span>Hello, world!</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>\n    </span><span><span><span>&lt;/</span></span><span>></span></span>\n  <span>)</span><span>;</span>\n<span>}</span>\n\n<span>const</span> <span>Demo</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>(</span>\n    <span><span><span>&lt;</span></span><span>></span></span><span>\n      </span><span><span><span>&lt;</span><span>App</span></span> <span>/></span></span><span>\n      </span><span><span><span>&lt;</span><span>ExpensiveTree</span></span> <span>/></span></span><span>\n    </span><span><span><span>&lt;/</span></span><span>></span></span>\n  <span>)</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>export</span> <span>default</span> Demo<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>当一部分 state 在高开销树的上层代码中使用时上述解法就无法奏效了。 比如，Demo 组件也需要 App 中的 color 状态，那这样便不可解决问题了？或者说又回到了 memo 和 PureComponent 上了啦？我们先来看看 Demo 组件的情况。</p>\n<div><pre><code><span>const</span> <span>ExpensiveTree</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>let</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>\n  <span>while</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> now <span>&lt;</span> <span>100</span><span>)</span> <span>{</span>\n    <span>// Artificial delay -- do nothing for 100ms</span>\n  <span>}</span>\n  <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>I am a very slow component tree.</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>const</span> <span>Demo</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>let</span> <span>[</span>color<span>,</span> setSolor<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>\"red\"</span><span>)</span><span>;</span>\n  <span>return</span> <span>(</span>\n    <span><span><span>&lt;</span>div</span> <span>style</span><span><span>=</span><span>{</span><span>{</span> color <span>}</span><span>}</span></span><span>></span></span><span>\n      </span><span><span><span>&lt;</span>input</span>\n        <span>type</span><span><span>=</span><span>\"</span>color<span>\"</span></span>\n        <span>value</span><span><span>=</span><span>{</span>color<span>}</span></span>\n        <span>onChange</span><span><span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=></span> <span>setSolor</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span></span>\n        <span>style</span><span><span>=</span><span>{</span><span>{</span> <span>display</span><span>:</span> <span>\"inline-block\"</span><span>,</span> <span>marginLeft</span><span>:</span> <span>600</span> <span>}</span><span>}</span></span>\n      <span>/></span></span><span>\n      </span><span><span><span>&lt;</span>p</span> <span>style</span><span><span>=</span><span>{</span><span>{</span> color <span>}</span><span>}</span></span><span>></span></span><span>Hello, world!</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>\n      </span><span><span><span>&lt;</span><span>ExpensiveTree</span></span> <span>/></span></span><span>\n    </span><span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span>)</span><span>;</span>\n<span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"解法二-内容提升\"> 解法二：内容提升</h3>\n<div><pre><code><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>\"react\"</span><span>;</span>\n\n<span>const</span> <span>ExpensiveTree</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>let</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>\n  <span>while</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> now <span>&lt;</span> <span>100</span><span>)</span> <span>{</span>\n    <span>// Artificial delay -- do nothing for 100ms</span>\n  <span>}</span>\n  <span>return</span> <span><span><span>&lt;</span>p</span><span>></span></span><span>I am a very slow component tree.</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>// 内容提升</span>\n<span>function</span> <span>ColorPicker</span><span>(</span><span><span>{</span> children <span>}</span></span><span>)</span> <span>{</span>\n  <span>let</span> <span>[</span>color<span>,</span> setSolor<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>\"red\"</span><span>)</span><span>;</span>\n  <span>return</span> <span>(</span>\n    <span><span><span>&lt;</span>div</span> <span>style</span><span><span>=</span><span>{</span><span>{</span> color <span>}</span><span>}</span></span><span>></span></span><span>\n      </span><span><span><span>&lt;</span>input</span>\n        <span>type</span><span><span>=</span><span>\"</span>color<span>\"</span></span>\n        <span>value</span><span><span>=</span><span>{</span>color<span>}</span></span>\n        <span>onChange</span><span><span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=></span> <span>setSolor</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span></span>\n        <span>style</span><span><span>=</span><span>{</span><span>{</span> <span>display</span><span>:</span> <span>\"inline-block\"</span><span>,</span> <span>marginLeft</span><span>:</span> <span>600</span> <span>}</span><span>}</span></span>\n      <span>/></span></span><span>\n      </span><span><span><span>&lt;</span>p</span><span>></span></span><span>当前的字体颜色</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>\n      </span><span>{</span>children<span>}</span><span>\n    </span><span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span>)</span><span>;</span>\n<span>}</span>\n\n<span>const</span> <span>Demo</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>return</span> <span>(</span>\n    <span><span><span>&lt;</span><span>ColorPicker</span></span><span>></span></span><span>\n      </span><span><span><span>&lt;</span>p</span><span>></span></span><span>--父组件内容--</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>\n      </span><span><span><span>&lt;</span><span>ExpensiveTree</span></span> <span>/></span></span><span>\n    </span><span><span><span>&lt;/</span><span>ColorPicker</span></span><span>></span></span>\n  <span>)</span><span>;</span>\n<span>}</span><span>;</span>\n\n<span>export</span> <span>default</span> Demo<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>ExpensiveTree 组件不会重新渲染的根本原因是，ColorPicker 组件中 color 改变后组件更新时 children 仍然保存着上一次从<code>Demo</code>中拿到的相同的<code>children</code>属性 。</p>\n<h3 id=\"总结\"> 总结</h3>\n<p>React 组件的更新，只有 props 或 state 改变才会触发。</p>\n<ul>\n<li>\n<p><a href=\"https://react.docschina.org/docs/react-api.html#reactpurecomponent\" target=\"_blank\" rel=\"noopener noreferrer\">React.PureComponent</a></p>\n</li>\n<li>\n<p><a href=\"https://react.docschina.org/docs/react-api.html#reactmemo\" target=\"_blank\" rel=\"noopener noreferrer\">React.memo</a></p>\n</li>\n<li>\n<h3 id=\"在你写-memo-之前\"> <a href=\"https://overreacted.io/zh-hans/before-you-memo/\" target=\"_blank\" rel=\"noopener noreferrer\">在你写 memo()之前</a></h3>\n</li>\n<li>\n<p><a href=\"https://react.docschina.org/docs/hooks-reference.html#usememo\" target=\"_blank\" rel=\"noopener noreferrer\">React.useMemo</a></p>\n</li>\n</ul>\n",
      "date_published": "2022-05-16T14:56:12.000Z",
      "date_modified": "2022-05-16T14:56:12.000Z",
      "authors": [
        {
          "name": "大眼猫"
        }
      ],
      "tags": [
        "React"
      ]
    },
    {
      "title": "React 进阶之“diff”算法",
      "url": "https://kangduu.github.io/website/website/react/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91React%E8%BF%9B%E9%98%B6%E4%B9%8B%E2%80%9Cdiff%E2%80%9D%E7%AE%97%E6%B3%95.html",
      "id": "https://kangduu.github.io/website/website/react/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91React%E8%BF%9B%E9%98%B6%E4%B9%8B%E2%80%9Cdiff%E2%80%9D%E7%AE%97%E6%B3%95.html",
      "content_html": "<h1 id=\"react-进阶之-diff-算法\"> React 进阶之“diff”算法</h1>\n<h3 id=\"react-元素的-key-属性有什么作用\"> React 元素的 key 属性有什么作用？</h3>\n<p>这是一道面试必问题，面试中你是如何回答这个问题的啦。从面试的角度来思考这个问题，面试官最想知道的是你是否对 React 底层原理有一定的了解。这个问题先记下来，我们先对<code>React的“diffing”算法</code>进行深入探讨，再回过头来回答这个问题。</p>\n",
      "date_published": "2022-05-16T14:56:12.000Z",
      "date_modified": "2022-05-16T14:56:12.000Z",
      "authors": [
        {
          "name": "大眼猫"
        }
      ],
      "tags": [
        "React"
      ]
    },
    {
      "title": "你对 react-fiber 有了解吗？",
      "url": "https://kangduu.github.io/website/website/react/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91fiber.html",
      "id": "https://kangduu.github.io/website/website/react/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91fiber.html",
      "content_html": "<h2 id=\"你对-react-fiber-有了解吗\"> 你对 react-fiber 有了解吗？</h2>\n<ol>\n<li>对于 react 原理的了解。</li>\n<li>对于新技术的敏感程度，求知欲。</li>\n</ol>\n<h3 id=\"目的\"> 目的</h3>\n<ul>\n<li>为了使 react 渲染的过程可以被<strong>中断</strong>，可以将控制权交还给浏览器，可以让位给<strong>高优先级的任务</strong>，浏览器空闲后再恢复渲染。</li>\n<li>对于计算量比较大的 js 计算或者 dom 计算，就不会显得特别的卡顿，而是一帧一帧的有规律的执行任务。</li>\n</ul>\n<p>🌰 中断</p>\n<div><pre><code><span>const</span> tasks <span>=</span> <span>[</span><span>]</span><span>;</span> <span>// 多个任务 同步</span>\n\n<span>function</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> task<span>;</span>\n  <span>while</span> <span>(</span><span>(</span>task <span>=</span> tasks<span>.</span><span>shift</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n    <span>execute</span><span>(</span>task<span>)</span><span>;</span> <span>// 这里执行execute需要5秒左右时间</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这种就会存在一个问题，每一个任务都需要大约 5 秒时间，那就会导致阻塞。\n如果在某个任务处停止啦？</p>\n<h3 id=\"使用-generator-模拟中断\"> <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator\" target=\"_blank\" rel=\"noopener noreferrer\">使用 generator 模拟中断</a></h3>\n<div><pre><code><span>const</span> tasks <span>=</span> <span>[</span><span>]</span><span>;</span> <span>// 多个任务 同步</span>\n\n<span>function</span><span>*</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n  <span>let</span> task<span>;</span>\n  <span>while</span> <span>(</span><span>(</span>task <span>=</span> tasks<span>.</span><span>shift</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>hasHighPriorityTask</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>yield</span><span>;</span>\n    <span>}</span>\n    <span>execute</span><span>(</span>task<span>)</span><span>;</span> <span>// 这里执行execute需要5秒左右时间</span>\n  <span>}</span>\n<span>}</span>\n\n<span>const</span> iterator <span>=</span> <span>run</span><span>(</span><span>)</span><span>;</span>\n\n<span>// 恢复</span>\niterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>上边的代码简单的实现了中断任务并可恢复。</p>\n<p><strong>🤔Question：</strong> 既然 generator 有类似的功能，为什么 react 不用 啦？</p>\n<ol>\n<li>\n<p>需要用 generator 将涉及到的所有的代码都包装成 generator * 形式，非常麻烦，工作量比较大。</p>\n</li>\n<li>\n<p>generator 内部是有状态的</p>\n</li>\n</ol>\n<div><pre><code><span>function</span><span>*</span> <span>doWork</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>\n  <span>const</span> x <span>=</span> <span>doExpensiveWorkA</span><span>(</span>a<span>)</span><span>;</span> <span>// x的值依赖a</span>\n  <span>yield</span><span>;</span>\n  <span>const</span> y <span>=</span> <span>doExpensiveWorkA</span><span>(</span>x<span>,</span> b<span>)</span><span>;</span> <span>// 依赖x的值</span>\n  <span>return</span> y<span>;</span>\n<span>}</span>\n<span>// 假设doExpensiveWorkA作用是将传入的参数相加后并返回结果。</span>\n<span>let</span> m <span>=</span> <span>1</span><span>,</span>\n  n <span>=</span> <span>2</span><span>;</span>\n<span>const</span> working <span>=</span> <span>doWork</span><span>(</span>m<span>,</span> n<span>)</span><span>;</span>\nworking<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span> <span>// x = m = 1</span>\n\nm <span>=</span> <span>4</span><span>;</span> <span>//如果这里改变了m，但是x已经done了，所以我们只能沿用旧的x值。</span>\nworking<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span> <span>// y = x + b = a + b = m + n;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"如何判断当前是否有高优先级任务\"> 如何判断当前是否有高优先级任务？</h3>\n<p>首先我们需要明白的是，当前 js 的环境其实并没有办法去判断是否有高优任务。<strong>🤔Question：</strong> 那你会怎么实现或者模拟一个啦？</p>\n<ul>\n<li>\n<p>只能约定一个合理的执行时间，当超过这个执行时间，如果任务任然没有执行完成，那就中断当前任务，将控制权交还给浏览器。</p>\n<p>普遍的显示器都是每秒 60 帧，<strong>1000ms / 60fps = 16ms</strong>。大概就是一帧的时间大约是 16 毫秒。</p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\" target=\"_blank\" rel=\"noopener noreferrer\">requestIdleCallback(callback[, options])</a> : callback 函数将在<strong>浏览器空闲时期</strong>被调用。</p>\n<p>并且 callback 函数会接收到一个名为 IdleDeadline 的参数，这个参数可以获取当前空闲时间以及回调是否在超时时间前已经执行的状态。</p>\n</li>\n<li>\n<p>浏览器在一帧内要做什么事情？</p>\n<ol>\n<li>处理用户输入事件</li>\n<li>JS 的执行</li>\n<li>requestAnimation 调用</li>\n<li>布局 layout</li>\n<li>绘制 paint</li>\n</ol>\n<blockquote>\n<p>16ms 一帧时间内，浏览器就没有空闲时间，\n即 0ms -&gt; requestIdleCallback 将没有时间被调用\n那一直都没有空闲时间啦？</p>\n</blockquote>\n</li>\n<li>\n<p>浏览器很忙怎么办？（空闲时间为 0）</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\" target=\"_blank\" rel=\"noopener noreferrer\">requestIdleCallback(callback[, options])</a> 第二个参数 <strong>{ timeout: 100 }</strong></p>\n<div><pre><code>window<span>.</span><span>requestIdleCallback</span><span>(</span>\n  <span>(</span><span>args</span><span>)</span> <span>=></span> <span>{</span>\n    console<span>.</span><span>log</span><span>(</span>args<span>)</span><span>;</span>\n  <span>}</span><span>,</span>\n  <span>{</span>\n    <span>timeout</span><span>:</span> <span>100</span><span>,</span>\n    <span>//如果指定了timeout，并且有一个正值，而回调在timeout毫秒过后还没有被调用，那么回调任务将放入事件循环中排队，即使这样做有可能对性能产生负面影响。</span>\n  <span>}</span>\n<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><a href=\"https://caniuse.com/?search=requestIdleCallback\" target=\"_blank\" rel=\"noopener noreferrer\">requestIdelCallback 的兼容性</a> 很差</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h2 id=\"说说-react-是如何实现-requestidlecallback-的\"> 说说 react 是如何实现 requestIdleCallback 的？</h2>\n<blockquote>\n<p>通过 messageChannel 模拟实现</p>\n</blockquote>\n<h2 id=\"react-中的任务优先级\"> react 中的任务优先级？</h2>\n<p>5 个优先级：</p>\n<ol>\n<li><strong>Immediate</strong> 最高优先级，这个优先级的任务应该马上被执行，且不能中断；</li>\n<li><strong>UserBlocking</strong> 这些任务一般是用户交互的结果，需要及时得到反馈；</li>\n<li><strong>Normal</strong> 不需要用户立刻能感受到的变化，比如网络请求等；</li>\n<li><strong>Low</strong> 这些任务可以被延后，但是最终也需要被执行；</li>\n<li><strong>Idle</strong> 可以被无限期延后，比如 console</li>\n</ol>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>同一级别的任务，先后顺序</p>\n</blockquote>\n</blockquote>\n</blockquote>\n",
      "date_published": "2022-05-16T14:56:12.000Z",
      "date_modified": "2022-05-16T14:56:12.000Z",
      "authors": [
        {
          "name": "大眼猫"
        }
      ],
      "tags": [
        "React"
      ]
    },
    {
      "title": "首页",
      "url": "https://kangduu.github.io/website/website/",
      "id": "https://kangduu.github.io/website/website/",
      "content_html": "",
      "date_published": "2022-04-29T09:54:32.000Z",
      "date_modified": "2022-05-05T10:01:30.000Z",
      "authors": [
        {
          "name": "大眼猫"
        }
      ],
      "tags": []
    },
    {
      "title": "TypeScript Syntax",
      "url": "https://kangduu.github.io/website/website/typescript/",
      "id": "https://kangduu.github.io/website/website/typescript/",
      "summary": "TypeScript is a strongly typed programming language that builds on JavaScript, giving you better tooling at any scale.",
      "content_html": "<h1 id=\"阅读角\"> 阅读角</h1>\n<ul>\n<li><a href=\"https://ts.yayujs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">TypeScript-yy</a></li>\n</ul>\n",
      "date_published": "2022-05-05T10:01:30.000Z",
      "date_modified": "2022-05-05T10:01:30.000Z",
      "authors": [
        {
          "name": "大眼猫"
        }
      ],
      "tags": [
        "React"
      ]
    }
  ]
}